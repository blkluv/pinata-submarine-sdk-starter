{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": ["import { GetSubmarinedContentOptions, PinataSubmarineInit, SubmarinedItem } from './types';\nimport FormData from 'form-data';\nimport fs from 'fs';\nimport PathLike = fs.PathLike;\nimport axios from 'axios';\n\nconst rfs = require(\"recursive-fs\");\nconst path = require(\"path\");\nconst url = `https://managed.mypinata.cloud/api/v1`;\nconst nftVerifyUrl = process.env.NODE_ENV === 'production' ? 'https://app.submarine.me/api' : 'http://localhost:3001/api'\n\nconst EVMChains = [\"Ethereum\", \"Polygon\", \"Avalanche\"];\n\nconst getFromAPI = async (endpoint: String, key: any) => {\n  try {\n    const response = await axios.get(`${url}/${endpoint}`, {\n      headers: {\n        \"Content-Type\": `application/json`,\n        \"x-api-key\": key,\n      },\n    })\n    return response.data;\n  } catch (error) {\n    throw error;\n  }\n}\n\nconst postToAPI = async (endpoint: String, data: any, key: any) => {\n  let response;\n  if (typeof data !== 'object') {\n    response = await axios.post(`${url}/${endpoint}`, data, {\n      headers: {\n        \"Content-Type\": `multipart/form-data; boundary=${data.getBoundary()}`,\n        \"x-api-key\": key,\n      },\n    })\n  } else {\n    response = await axios.post(`${url}/${endpoint}`, data, {\n      headers: {\n        \"Content-Type\": `application/json`,\n        \"x-api-key\": key,\n      },\n    })\n  }\n\n  return response.data;\n}\n\nconst deleteFromAPI = async (endpoint: String, key: any) => {\n  const response = await axios.delete(`${url}/${endpoint}`, {\n    headers: {\n      \"Content-Type\": `application/json`,\n      \"x-api-key\": key,\n    }\n  })\n\n  return response.data;\n}\n\nconst putToAPI = async (endpoint: String, data: any, key: any) => {\n  let response;\n\n  if (typeof data !== 'object') {\n    response = await axios.put(`${url}/${endpoint}`, data, {\n      headers: {\n        \"Content-Type\": `multipart/form-data; boundary=${data.getBoundary()}`,\n        \"x-api-key\": key,\n      },\n    })\n  } else {\n    response = await axios.put(`${url}/${endpoint}`, data, {\n      headers: {\n        \"Content-Type\": `application/json`,\n        \"x-api-key\": key,\n      },\n    })\n  }\n\n  return response.data;\n}\n\nconst isDirectory = async (filepath: PathLike) => {\n  const stats = fs.statSync(filepath);\n  if (stats.isDirectory()) {\n    return true;\n  }\n  return false;\n}\n\nexport class Submarine {\n  submarineKey: String\n  gatewayUrl: String\n\n  constructor(submarineApiKey: String, gatewayUrl: String) {\n    this.submarineKey = submarineApiKey;\n    this.gatewayUrl = gatewayUrl;\n  }\n\n  async getSubmarinedContentByCid(submarinedCid: String) {\n    const response = await getFromAPI(`content?cidContains=${submarinedCid}`, this.submarineKey);\n    return response;\n  }\n\n  async getSubmarinedContent(options: GetSubmarinedContentOptions) {\n    try {\n      if (!this.submarineKey) {\n        throw \"No Submarine key provided\"\n      }\n\n      let queryString = `content?`;\n\n      if (options.limit) {\n        queryString = queryString + `limit=${options.limit}&`;\n      }\n\n      if (options.offset) {\n        queryString = queryString + `offset=${options.offset}&`;\n      }\n\n      if (options.name) {\n        queryString = queryString + `name=${options.name}&`;\n      }\n\n      if (options.originalName) {\n        queryString = queryString + `originalname=${options.originalName}&`;\n      }\n\n      if (options.submarinedCid) {\n        queryString = queryString + `cidContains=${options.submarinedCid}&`;\n      }\n\n      if (options.createdAtStart) {\n        queryString = queryString + `createdAtStart=${options.createdAtStart}&`;\n      }\n\n      if (options.createdAtEnd) {\n        queryString = queryString + `createdAtEnd=${options.createdAtEnd}&`;\n      }\n\n      if (options.fileSizeMaximum) {\n        queryString = queryString + `pinSizeMax=${options.fileSizeMaximum}&`;\n      }\n\n      if (options.fileSizeMinimum) {\n        queryString = queryString + `pinSizeMin=${options.fileSizeMinimum}&`;\n      }\n\n      if (options.order) {\n        queryString = queryString + `order=${options.order}&`;\n      }\n\n      if (options.metadata) {\n        queryString = queryString + `metadata[keyvalues]=${options.metadata}`\n      }\n\n      const { items } = await getFromAPI(queryString, this.submarineKey);\n\n      return items;\n    } catch (error) {\n      throw error\n    }\n  }\n\n  async listFolderContent(itemId: String, offset: String = \"0\") {\n    const listData = await getFromAPI(`content/${itemId}/list?includePaths=true&limit=10&offset=${offset}`, this.submarineKey);\n    const { items: directoryItems } = listData;\n    const indexHtml = directoryItems.filter((i: SubmarinedItem) => i.originalname.includes(\"index.html\"));\n    const hasIndexHtml = indexHtml.length > 0;\n    const childContent = directoryItems;\n    return {\n      childContent,\n      hasIndexHtml\n    };\n  }\n\n  async generateAccessLink(timeoutSeconds: Number, contentId: string, submarinedCid: String, filepath?: String) {\n    const body = {\n      timeoutSeconds,\n      contentIds: [contentId],\n    };\n    const tokenRes = await postToAPI('auth/content/jwt', body, this.submarineKey);\n\n    if (filepath) {\n      return `${this.gatewayUrl}/ipfs/${submarinedCid}/${filepath}?accessToken=${tokenRes}`;\n    }\n\n    const folderCheck = await this.listFolderContent(contentId);\n\n    if (folderCheck.hasIndexHtml) {\n      return `${this.gatewayUrl}/ipfs/${submarinedCid}/index.html?accessToken=${tokenRes}`;\n    }\n    return `${this.gatewayUrl}/ipfs/${submarinedCid}?accessToken=${tokenRes}`;\n  }\n\n  async uploadFileOrFolder(filepath: PathLike, name?: String, metadata?: any, cidVersion?: Number) {\n    try {\n      let data = new FormData();\n\n      const directory = await isDirectory(filepath);\n\n      if (directory) {\n        const { files } = await rfs.read(filepath);\n\n        for (const file of files) {\n          const content = fs.readFileSync(file);\n          data.append(`files`, content, {\n            filepath: path.join(filepath, path.relative(filepath, file)),\n          });\n        }\n\n      } else {\n        data.append(\"files\", fs.createReadStream(filepath));\n      }\n\n      data.append(\"cidVersion\", cidVersion && (cidVersion === 1 || cidVersion === 0) ? cidVersion.toString() : \"0\");\n      data.append(\"pinToIPFS\", \"false\");\n      data.append(\"wrapWithDirectory\", \"false\");\n      if (name) {\n        data.append(\"name\", name);\n      }\n\n      if (metadata) {\n        data.append(\"metadata\", JSON.stringify(metadata));\n      }\n\n      const response = await postToAPI(\"content\", data, this.submarineKey);\n\n      return response;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async uploadJson(content: any, name: string, cidVersion?: Number, metadata?: any) {\n    const body = {\n      content: JSON.stringify(content),\n      name,\n      pinToIPFS: false,\n      metadata: metadata ? JSON.stringify(metadata) : \"{}\",\n      cidVersion: cidVersion && (cidVersion === 1 || cidVersion === 0) ? cidVersion.toString() : 0\n    }\n\n    return await postToAPI(\"content/json\", body, this.submarineKey);\n  }\n\n  async updateFileName(contentId: String, name: String) {\n    const body = {\n      name,\n      pinToIPFS: false\n    }\n\n    return await putToAPI(`content/${contentId}`, body, this.submarineKey);\n  }\n\n  async updateFileMetadata(contentId: String, metadata: any) {\n    return await putToAPI(`content/${contentId}/metadata`, metadata, this.submarineKey);\n  }\n\n  async makeFilePublic(contentId: String) {\n    const body = {\n      pinToIPFS: true\n    }\n\n    return await putToAPI(`content/${contentId}`, body, this.submarineKey);\n  }\n\n  async deleteContent(contentId: String) {\n    return await deleteFromAPI(`content/${contentId}`, this.submarineKey);\n  }\n\n  async verifyEVMNFT(signature: string, address: string, messageId: string, blockchain: string, contractAddress: string, network: string, tokenId?: string) {\n    if (EVMChains.includes(blockchain)) {\n      console.log({ messageId });\n      const response = await axios.post(`${nftVerifyUrl}/verify`, {\n        contractAddress: contractAddress,\n        network,\n        signature,\n        blockchain,\n        messageId,\n        address,\n        tokenId: tokenId\n      });\n      if (response.data === true) {\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      throw \"Non EVM chain submitted\"\n    }\n  }\n\n  async getEVMMessageToSign(blockchain: string, contractAddress: string) {\n    if (EVMChains.includes(blockchain)) {\n      const response = await axios.get(`${nftVerifyUrl}/verify?contract=${contractAddress}`);\n      return response.data;\n    } else if (blockchain === \"Solana\") {\n      const response = await axios.get(`${nftVerifyUrl}/verifySol?updateAuthority=${contractAddress}`);\n      return response.data;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
