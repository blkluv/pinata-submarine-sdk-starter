var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  Submarine: () => Submarine
});
module.exports = __toCommonJS(src_exports);
var import_form_data = __toESM(require("form-data"));
var import_fs = __toESM(require("fs"));
var import_axios = __toESM(require("axios"));
const PathLike = import_fs.default.PathLike;
const rfs = require("recursive-fs");
const path = require("path");
const url = `https://managed.mypinata.cloud/api/v1`;
const nftVerifyUrl = process.env.NODE_ENV === "production" ? "https://app.submarine.me/api" : "http://localhost:3001/api";
const EVMChains = ["Ethereum", "Polygon", "Avalanche"];
const getFromAPI = async (endpoint, key) => {
  try {
    const response = await import_axios.default.get(`${url}/${endpoint}`, {
      headers: {
        "Content-Type": `application/json`,
        "x-api-key": key
      }
    });
    return response.data;
  } catch (error) {
    throw error;
  }
};
const postToAPI = async (endpoint, data, key) => {
  let response;
  if (typeof data !== "object") {
    response = await import_axios.default.post(`${url}/${endpoint}`, data, {
      headers: {
        "Content-Type": `multipart/form-data; boundary=${data.getBoundary()}`,
        "x-api-key": key
      }
    });
  } else {
    response = await import_axios.default.post(`${url}/${endpoint}`, data, {
      headers: {
        "Content-Type": `application/json`,
        "x-api-key": key
      }
    });
  }
  return response.data;
};
const deleteFromAPI = async (endpoint, key) => {
  const response = await import_axios.default.delete(`${url}/${endpoint}`, {
    headers: {
      "Content-Type": `application/json`,
      "x-api-key": key
    }
  });
  return response.data;
};
const putToAPI = async (endpoint, data, key) => {
  let response;
  if (typeof data !== "object") {
    response = await import_axios.default.put(`${url}/${endpoint}`, data, {
      headers: {
        "Content-Type": `multipart/form-data; boundary=${data.getBoundary()}`,
        "x-api-key": key
      }
    });
  } else {
    response = await import_axios.default.put(`${url}/${endpoint}`, data, {
      headers: {
        "Content-Type": `application/json`,
        "x-api-key": key
      }
    });
  }
  return response.data;
};
const isDirectory = async (filepath) => {
  const stats = import_fs.default.statSync(filepath);
  if (stats.isDirectory()) {
    return true;
  }
  return false;
};
class Submarine {
  submarineKey;
  gatewayUrl;
  constructor(submarineApiKey, gatewayUrl) {
    this.submarineKey = submarineApiKey;
    this.gatewayUrl = gatewayUrl;
  }
  async getSubmarinedContentByCid(submarinedCid) {
    const response = await getFromAPI(`content?cidContains=${submarinedCid}`, this.submarineKey);
    return response;
  }
  async getSubmarinedContent(options) {
    try {
      if (!this.submarineKey) {
        throw "No Submarine key provided";
      }
      let queryString = `content?`;
      if (options.limit) {
        queryString = queryString + `limit=${options.limit}&`;
      }
      if (options.offset) {
        queryString = queryString + `offset=${options.offset}&`;
      }
      if (options.name) {
        queryString = queryString + `name=${options.name}&`;
      }
      if (options.originalName) {
        queryString = queryString + `originalname=${options.originalName}&`;
      }
      if (options.submarinedCid) {
        queryString = queryString + `cidContains=${options.submarinedCid}&`;
      }
      if (options.createdAtStart) {
        queryString = queryString + `createdAtStart=${options.createdAtStart}&`;
      }
      if (options.createdAtEnd) {
        queryString = queryString + `createdAtEnd=${options.createdAtEnd}&`;
      }
      if (options.fileSizeMaximum) {
        queryString = queryString + `pinSizeMax=${options.fileSizeMaximum}&`;
      }
      if (options.fileSizeMinimum) {
        queryString = queryString + `pinSizeMin=${options.fileSizeMinimum}&`;
      }
      if (options.order) {
        queryString = queryString + `order=${options.order}&`;
      }
      if (options.metadata) {
        queryString = queryString + `metadata[keyvalues]=${options.metadata}`;
      }
      const { items } = await getFromAPI(queryString, this.submarineKey);
      return items;
    } catch (error) {
      throw error;
    }
  }
  async listFolderContent(itemId, offset = "0") {
    const listData = await getFromAPI(`content/${itemId}/list?includePaths=true&limit=10&offset=${offset}`, this.submarineKey);
    const { items: directoryItems } = listData;
    const indexHtml = directoryItems.filter((i) => i.originalname.includes("index.html"));
    const hasIndexHtml = indexHtml.length > 0;
    const childContent = directoryItems;
    return {
      childContent,
      hasIndexHtml
    };
  }
  async generateAccessLink(timeoutSeconds, contentId, submarinedCid, filepath) {
    const body = {
      timeoutSeconds,
      contentIds: [contentId]
    };
    const tokenRes = await postToAPI("auth/content/jwt", body, this.submarineKey);
    if (filepath) {
      return `${this.gatewayUrl}/ipfs/${submarinedCid}/${filepath}?accessToken=${tokenRes}`;
    }
    const folderCheck = await this.listFolderContent(contentId);
    if (folderCheck.hasIndexHtml) {
      return `${this.gatewayUrl}/ipfs/${submarinedCid}/index.html?accessToken=${tokenRes}`;
    }
    return `${this.gatewayUrl}/ipfs/${submarinedCid}?accessToken=${tokenRes}`;
  }
  async uploadFileOrFolder(filepath, name, metadata, cidVersion) {
    try {
      let data = new import_form_data.default();
      const directory = await isDirectory(filepath);
      if (directory) {
        const { files } = await rfs.read(filepath);
        for (const file of files) {
          const content = import_fs.default.readFileSync(file);
          data.append(`files`, content, {
            filepath: path.join(filepath, path.relative(filepath, file))
          });
        }
      } else {
        data.append("files", import_fs.default.createReadStream(filepath));
      }
      data.append("cidVersion", cidVersion && (cidVersion === 1 || cidVersion === 0) ? cidVersion.toString() : "0");
      data.append("pinToIPFS", "false");
      data.append("wrapWithDirectory", "false");
      if (name) {
        data.append("name", name);
      }
      if (metadata) {
        data.append("metadata", JSON.stringify(metadata));
      }
      const response = await postToAPI("content", data, this.submarineKey);
      return response;
    } catch (error) {
      throw error;
    }
  }
  async uploadJson(content, name, cidVersion, metadata) {
    const body = {
      content: JSON.stringify(content),
      name,
      pinToIPFS: false,
      metadata: metadata ? JSON.stringify(metadata) : "{}",
      cidVersion: cidVersion && (cidVersion === 1 || cidVersion === 0) ? cidVersion.toString() : 0
    };
    return await postToAPI("content/json", body, this.submarineKey);
  }
  async updateFileName(contentId, name) {
    const body = {
      name,
      pinToIPFS: false
    };
    return await putToAPI(`content/${contentId}`, body, this.submarineKey);
  }
  async updateFileMetadata(contentId, metadata) {
    return await putToAPI(`content/${contentId}/metadata`, metadata, this.submarineKey);
  }
  async makeFilePublic(contentId) {
    const body = {
      pinToIPFS: true
    };
    return await putToAPI(`content/${contentId}`, body, this.submarineKey);
  }
  async deleteContent(contentId) {
    return await deleteFromAPI(`content/${contentId}`, this.submarineKey);
  }
  async verifyEVMNFT(signature, address, messageId, blockchain, contractAddress, network, tokenId) {
    if (EVMChains.includes(blockchain)) {
      console.log({ messageId });
      const response = await import_axios.default.post(`${nftVerifyUrl}/verify`, {
        contractAddress,
        network,
        signature,
        blockchain,
        messageId,
        address,
        tokenId
      });
      if (response.data === true) {
        return true;
      } else {
        return false;
      }
    } else {
      throw "Non EVM chain submitted";
    }
  }
  async getEVMMessageToSign(blockchain, contractAddress) {
    if (EVMChains.includes(blockchain)) {
      const response = await import_axios.default.get(`${nftVerifyUrl}/verify?contract=${contractAddress}`);
      return response.data;
    } else if (blockchain === "Solana") {
      const response = await import_axios.default.get(`${nftVerifyUrl}/verifySol?updateAuthority=${contractAddress}`);
      return response.data;
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Submarine
});
//# sourceMappingURL=index.js.map
